#include"DynamicPrograming.h"
using namespace std;
int main()
{
	/*vector<vector<string>> iVec = {
		{"1","0","1","0","0"},
		{"1","0","1","1","1"},
		{"1","1","1","1","1"},
		{"1","0","0","1","0"}
	};

	int iSize = iVec.size();
	cout << iVec[0][1] << endl;

	vector<vector<int>> obstacleGrid = { {1, 2},{5, 6},{1, 1}};

	MinPath difPath;
	int i = difPath.minPathSum(obstacleGrid);

	string iTest = "226";
	DecodeMethod pDecode;
	i = pDecode.numDecodings(iTest);

	LongestSubStr subStr;
	int Pos = subStr.lengthOfLongestSubstring("pwwkew");*/

	//Convert pConvert;
	//string s = pConvert.convert("AB", 1);

	//CommonSubstr comStr;
	//int iResult = comStr.longestCommonSubsequence("oxcpqrsvwf", "shmtulqrypy");

	//PivotIndex pivotIndex;
	//vector<int> obstacleGrid = { -1,-1,-1,-1,1,1 };
	//int idx = pivotIndex.pivotIndex(obstacleGrid);

	//SpiralOrder spiralOrder;
	//vector<vector<int>> iVec1 = { {1,2,3},{4,5,6},{7,8,9} };
	//vector<vector<int>> iVec = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
	/*vector<vector<int>> iVec2 = {{ 6 ,9,7}};
	vector<int> pRefd = spiralOrder.spiralOrder(iVec2);*/
	//vector<int> iVec1 = { 2, 3, 1, 2, 4, 3 };
	//vector<int> iVec2 = {1,4,4 };
	//vector<int> iVec3 = { 5, 1, 3, 5, 10, 7, 4, 9, 2, 8 };
	//MinSubArr minArr;
	//int iLen = minArr.minSubArrayLen(7, iVec1);

	/*MyCircularQueue* obj = new MyCircularQueue(5);
	bool bFull = obj->isFull();*/

	//int i = 'B' - 'A';
	//{'A', 'A', 'A', 'B', 'B','B'}
	//{'A', 'B', 'C', 'D', 'E', 'A', 'B', 'C', 'D', 'E'};
	/*vector<char> iVec = { 'A', 'B', 'C', 'D', 'E', 'A', 'B', 'C', 'D', 'E' };
	TaskOperator opt;
	int iRes = opt.leastIntervalEasy(iVec, 4);*/

	//ValidSyntax pVal;
	//bool bRes = pVal.isValid("()");
	//DailyTemperatures pDaily;
	//vector<int> pVec = { 73, 74, 75, 71, 69, 72, 76, 73 };
	//vector<int> Res = pDaily.dailyTemp(pVec);

	//EvalRPN evalRPN;
	//vector<string> pVec = { "10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+" };
	//int iRes = evalRPN.evalRPN(pVec);
	//vector<int> pVec = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
	//vector<int> pVec = { 5, 4, 1, 2};
	//pVec = { 5, 2, 1, 2,1,5 };
	//pVec = { 4,2,3 };
	//pVec = { 6,4,2,0,3,2,0,3,1,4,5,3,2,7,5,3,0,1,2,1,3,4,6,8,1,3 };
	//pVec = { 8,2,8,9,0,1,7,7,9 };
	//TrapWater pTrapWawr;
	//int iRes = pTrapWawr.TrapEasyWay(pVec);

	//vector<int> pVec = { 5,9,3,2,1,0,2,3,3,1,0,0 };

	//vector<vector<char>> iVec1 = { { 'A','B','C','D' },{ 'S','F','C','S' },{ 'A','D','E','E' } };
	//iVec1 = { { 'A','B','C','E' },{ 'S','F','C','S' },{ 'A','D','E','E' } };
	//iVec1 = { { 'C', 'A', 'A' },{ 'A', 'A', 'A' },{ 'B', 'C', 'D' } };

	//FindWord find;
	//bool bres = find.existSaveTime(iVec1, "ABCCED");



	//vector<vector<int>> pVec = { {1,3},{2,6 }, { 8,10 }, { 15,18} };

	//pVec = { {1,4},{4,5} };
	//pVec = { { 1,4 },{ 2,3 } };
	//pVec = { { 2,3 },{ 4,5 },{ 6,7 },{ 8,9 },{ 1,10} };
	//vector<int> pVec = { 1,1,2,1,2,2,1 };
	//pVec = { 5,3,1,2,6,7,8,5,5 };
	//pVec = { 1,2,3,4 };
	//WiggleSort Rec;
	//Rec.wiggleSort(pVec);

	//ExchangeNode::ListNode * head = new ExchangeNode::ListNode(1);
	//ExchangeNode::ListNode *Tmp = head;
	//for (int i = 2; i <= 10; i++)
	//{
	//	ExchangeNode::ListNode * TmpNode = new ExchangeNode::ListNode(i);
	//	Tmp->next = TmpNode;
	//	Tmp = TmpNode;
	//}

	//ExchangeNode exNoe;
	//ExchangeNode::ListNode * headRes = exNoe.swapPairsII(head);

	//vector<int> pVec = { 1,1,2,1,2,2,1 };
	//DividSubset divie;
	//divie.canPartitionKSubsets(pVec, 3);

	//vector<int> pVec = { 5,7,7,8,8,10 };
	//FindFirstAndLast test;
	//vector<int> Res = test.searchRange(pVec, 8);

	//vector<int> pVec = { 2,0 };
	//JumpGame jumpGame;
	//bool bCanJump = jumpGame.CanJump(pVec);

	//vector<vector<int>> pVec = {{9, 9, 4},{6, 6, 8},{2, 1, 1}};

	//pVec = {{ 0,  1,  2,  3,  4,  5,  6,  7,   8,  9},
	//		{ 19, 18, 17, 16, 15, 14, 13, 12, 11, 10 },
	//		{ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29 },
	//		{ 39, 38, 37, 36, 35, 34, 33, 32, 31, 30 },
	//		{ 40, 41, 42, 43, 44, 45, 46, 47, 48, 49 },
	//		{ 59, 58, 57, 56, 55, 54, 53, 52, 51, 50 },
	//		{ 60, 61, 62, 63, 64, 65, 66, 67, 68, 69 },
	//		{ 79, 78, 77, 76, 75, 74, 73, 72, 71, 70 },
	//		{ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89 },
	//		{ 99, 98, 97, 96, 95, 94, 93, 92, 91, 90 },
	//		{ 100,101, 102, 103, 104, 105, 106, 107, 108, 109 },
	//		{ 119, 118, 117, 116, 115, 114, 113, 112, 111, 110 },
	//		{ 120, 121, 122, 123, 124, 125, 126, 127, 128, 129 },
	//		{ 139, 138, 137, 136, 135, 134, 133, 132, 131, 130 },
	//		{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };
	//LongestIncreasingPath LONtEST;
	//int iLen = LONtEST.longestIncreasingPath(pVec);

	//vector<int> pVec1 = {  5,2,6,1  };
	//CountSmaller smallerTest;
	//vector<int> pVec = smallerTest.countSmaller(pVec1);


	//AtomCnt pTesat;
	//string sRes = pTesat.countOfAtoms("(Cm39)5(Ga28Sb45Rb8)20(Bk13Fr29As)45");

//string sNum = "1";
//int iRes = stoi(sNum);
	//vector<int> pVec1 = { 1,2,2 };
	//GiveOutCandy candy;
	//int iRes = candy.candy(pVec1);
	//vector<string> pStr = { "i", "love", "leetcode", "i", "love", "coding" };
	//TopKFrequent tes;
	//vector<string> pVec;
	//pVec = tes.topKFrequent(pStr, 2);


	//vector<string> pStr = { "hot","dot","dog","lot","log","cog" };
	//LadderLength LE;
	//int iRes = LE.ladderLength("hit", "cog", pStr);

	//vector<vector<char>> pGrif = { { '1','1','1','1','1' }, { '1','1', '0', '1', '0' }, { '1','1', '0', '0', '0' }, { '0', '0', '1', '0', '1' } };

	//pGrif = { { '1','1','1' },{'0', '1', '0' },{ '1','1', '1'} };
	//NumIslands pNums;
	//int iIsCnt = pNums.numIslands(pGrif);

	//priority_queue<int, vector<int>, less<int>> pQue;
	//vector<int> pVec1 = { 3,2,3,1,2,4,5,5,6 };
	//FindKLargest find;
	//sort(pVec1.begin(), pVec1.end(), greater<int>());
	//int i = find.findKthLargest(pVec1,4);
	vector<int> pVec = { 1,-1,1,1,1,1,1,1 };
	//pVec = { 0,0,0,0,-1,-1,0,-1,-1,-1,0 };
	pVec = { -10,9,20,-1,-1,15,7 };
	//pVec = { 1,2,3 };
	//pVec = { -7,-2,-5};

	BinaryTree pTree;
	BinaryTree::TreeNode *pHead = pTree.ConstructTreeMain(pVec);
	int iMax = pHead->val;
	int i = pTree.maxPathSum(pHead,iMax);
	//vector<BinaryTree::TreeNode*> pRes = pTree.findDuplicateSubtrees(pHead);
	//map<string, int> pMap;
	//vector<BinaryTree::TreeNode*> pResVec;
	//pTree.PreOrderII(pHead, pMap, pResVec);

	//vector<string> pVec = { "eat", "tea", "tan", "ate", "nat", "bat" };
	//GroupAnagrams pTest;
	//vector<vector<string>> pResVec = pTest.groupAnagrams(pVec);

LongestSubstring testl;
string s = "aabbaabsfeg";
int iRes = testl.longestSubstring(s, 3);
	return 0;
}



